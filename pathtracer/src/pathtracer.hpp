#pragma once
#include <glm/glm.hpp>
#include <vector>
#include <model.hpp>
#include "hdr_image.hpp"

#ifdef M_PI
#undef M_PI
#endif
#define M_PI 3.14159265359f
#define EPSILON 0.0001f

using namespace glm;

///////////////////////////////////////////////////////////////////////////
// Creates a TBN matrix for the tangent space orthonormal to N
// We use the method from Duff et al. "Building an Orthonormal Basis, Revisited"
// https://jcgt.org/published/0006/01/01/
// which uses quaternion math to calculate the tangent vectors
///////////////////////////////////////////////////////////////////////////
glm::mat3 tangent_space(glm::vec3 n);

namespace pathtracer {
///////////////////////////////////////////////////////////////////////////////
// Path Tracer settings
///////////////////////////////////////////////////////////////////////////////
struct Settings {
	int subsampling;
	int max_bounces;
	int max_paths_per_pixel;
};
extern Settings settings;

///////////////////////////////////////////////////////////////////////////////
// Environment
///////////////////////////////////////////////////////////////////////////////
struct Environment {
	float multiplier;
	HDRImage map;
};
extern Environment environment;

///////////////////////////////////////////////////////////////////////////
// The rendered image
///////////////////////////////////////////////////////////////////////////
struct Image {
	int width, height, number_of_samples = 0;
	std::vector<glm::vec3> data;
	float* get_ptr() {
		return &data[0].x;
	}
};
extern Image rendered_image;

///////////////////////////////////////////////////////////////////////////////
// The light sources
///////////////////////////////////////////////////////////////////////////////
struct PointLight {
	float intensity_multiplier;
	vec3 color;
	vec3 position;
};
extern PointLight point_light;

struct DiscLight {
	float intensity_multiplier;
	vec3 color;
	vec3 position;
	vec3 direction;
	float radius;
};
extern std::vector<DiscLight> disc_lights;

///////////////////////////////////////////////////////////////////////////
/// Restart rendering of image
///////////////////////////////////////////////////////////////////////////
void restart();

///////////////////////////////////////////////////////////////////////////
/// Get the amount of samples taken in the current image
///////////////////////////////////////////////////////////////////////////
int get_sample_count();

///////////////////////////////////////////////////////////////////////////
/// On window resize, window size is passed in, actual size of pathtraced
/// image may be smaller (if we're subsampling for speed)
///////////////////////////////////////////////////////////////////////////
void resize(int w, int h);

///////////////////////////////////////////////////////////////////////////
/// Trace one path per pixel
///////////////////////////////////////////////////////////////////////////
void trace_paths(const mat4& V, const mat4& P);
}; // namespace pathtracer
